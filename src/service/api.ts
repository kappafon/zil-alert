/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * zil-be-api
 * Zil BE API
 *
 * OpenAPI spec version: 0.1.0
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from 'url';
import * as portableFetch from 'portable-fetch';
import { Configuration } from './configuration';

const BASE_PATH = '/'.replace(/\/+$/, '');

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ',',
    ssv: ' ',
    tsv: '\t',
    pipes: '|'
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(
        configuration: Configuration,
        protected basePath: string = BASE_PATH,
        protected fetch: FetchAPI = portableFetch
    ) {
        this.configuration = configuration;
        this.basePath = configuration.basePath || this.basePath;
    }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name = 'RequiredError';
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 *
 * @export
 * @enum {string}
 */
export enum AlertThrottleEnum {
    Once = <any>'once',
    OncePerHour = <any>'oncePerHour',
    Recurring = <any>'recurring'
}
/**
 *
 * @export
 * @interface CreateNewAlertContractRequestDTO
 */
export interface CreateNewAlertContractRequestDTO {
    /**
     *
     * @type {string}
     * @memberof CreateNewAlertContractRequestDTO
     */
    tokenId: string;
    /**
     *
     * @type {number}
     * @memberof CreateNewAlertContractRequestDTO
     */
    priceTarget: number;
    /**
     *
     * @type {string}
     * @memberof CreateNewAlertContractRequestDTO
     */
    targetType: TargetTypeEnum;
    /**
     *
     * @type {string}
     * @memberof CreateNewAlertContractRequestDTO
     */
    trend: TrendEnum;
    /**
     *
     * @type {AlertThrottleEnum}
     * @memberof CreateNewAlertContractRequestDTO
     */
    throttling: AlertThrottleEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum TargetTypeEnum {
    Exact = <any>'exact',
    Percentage = <any>'percentage'
}
/**
 * @export
 * @enum {string}
 */
export enum TrendEnum {
    Lower = <any>'lower',
    Higher = <any>'higher'
}
/**
 *
 * @export
 * @interface CreateNewAlertContractResponseDTO
 */
export interface CreateNewAlertContractResponseDTO {
    /**
     *
     * @type {string}
     * @memberof CreateNewAlertContractResponseDTO
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof CreateNewAlertContractResponseDTO
     */
    tokenId: string;
    /**
     *
     * @type {number}
     * @memberof CreateNewAlertContractResponseDTO
     */
    priceTarget: number;
    /**
     *
     * @type {string}
     * @memberof CreateNewAlertContractResponseDTO
     */
    targetType: TargetTypeEnum;
    /**
     *
     * @type {string}
     * @memberof CreateNewAlertContractResponseDTO
     */
    trend: TrendEnum;
    /**
     *
     * @type {AlertThrottleEnum}
     * @memberof CreateNewAlertContractResponseDTO
     */
    throttling: AlertThrottleEnum;
}

/**
 *
 * @export
 * @interface CustomError
 */
export interface CustomError {
    /**
     *
     * @type {string}
     * @memberof CustomError
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof CustomError
     */
    message: string;
    /**
     *
     * @type {string}
     * @memberof CustomError
     */
    stack?: string;
    /**
     *
     * @type {number}
     * @memberof CustomError
     */
    status?: number;
    /**
     *
     * @type {ModelObject}
     * @memberof CustomError
     */
    data?: any;
}
/**
 *
 * @export
 * @interface GetUserContractsResponseDTO
 */
export interface GetUserContractsResponseDTO {
    /**
     *
     * @type {Array<UserAlertContracts>}
     * @memberof GetUserContractsResponseDTO
     */
    alertContracts: Array<UserAlertContracts>;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum LicenseType {
    NUMBER_0 = <any>0,
    NUMBER_1 = <any>1
}
/**
 *
 * @export
 * @interface LoginUserRequestDTO
 */
export interface LoginUserRequestDTO {
    /**
     *
     * @type {string}
     * @memberof LoginUserRequestDTO
     */
    username: string;
    /**
     *
     * @type {string}
     * @memberof LoginUserRequestDTO
     */
    password: string;
}
/**
 *
 * @export
 * @interface LoginUserResponseDTO
 */
export interface LoginUserResponseDTO {
    /**
     *
     * @type {string}
     * @memberof LoginUserResponseDTO
     */
    accessToken: string;
    /**
     *
     * @type {Date}
     * @memberof LoginUserResponseDTO
     */
    licensedUntil?: Date;
    /**
     *
     * @type {LicenseType}
     * @memberof LoginUserResponseDTO
     */
    license: LicenseType;
    /**
     *
     * @type {Array<TokenDTO>}
     * @memberof LoginUserResponseDTO
     */
    supportedTokens: Array<TokenDTO>;
}
/**
 *
 * @export
 * @interface RegisterUserRequestDTO
 */
export interface RegisterUserRequestDTO {
    /**
     *
     * @type {string}
     * @memberof RegisterUserRequestDTO
     */
    username: string;
    /**
     *
     * @type {string}
     * @memberof RegisterUserRequestDTO
     */
    password: string;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum TOKENSIDS {
    Zil1p5suryq6q647usxczale29cu3336hhp376c627 = <any>'zil1p5suryq6q647usxczale29cu3336hhp376c627',
    Zil14pzuzq6v6pmmmrfjhczywguu0e97djepxt8g3e = <any>'zil14pzuzq6v6pmmmrfjhczywguu0e97djepxt8g3e',
    Zil1l0g8u6f9g0fsvjuu74ctyla2hltefrdyt7k5f4 = <any>'zil1l0g8u6f9g0fsvjuu74ctyla2hltefrdyt7k5f4',
    Zil18f5rlhqz9vndw4w8p60d0n7vg3n9sqvta7n6t2 = <any>'zil18f5rlhqz9vndw4w8p60d0n7vg3n9sqvta7n6t2',
    Zil14jmjrkvfcz2uvj3y69kl6gas34ecuf2j5ggmye = <any>'zil14jmjrkvfcz2uvj3y69kl6gas34ecuf2j5ggmye',
    Zil17tsmlqgnzlfxsq4evm6n26txm2xlp5hele0kew = <any>'zil17tsmlqgnzlfxsq4evm6n26txm2xlp5hele0kew',
    Zil1r9dcsrya4ynuxnzaznu00e6hh3kpt7vhvzgva0 = <any>'zil1r9dcsrya4ynuxnzaznu00e6hh3kpt7vhvzgva0',
    Zil1hau7z6rjltvjc95pphwj57umdpvv0d6kh2t8zk = <any>'zil1hau7z6rjltvjc95pphwj57umdpvv0d6kh2t8zk',
    Zil1p2cp77kz06wlxeyha4psawencm5gx8ttcwsxdn = <any>'zil1p2cp77kz06wlxeyha4psawencm5gx8ttcwsxdn',
    Zil1rk9vdfu2xsp7y4h24qg78n6ss23mxxge5slsv2 = <any>'zil1rk9vdfu2xsp7y4h24qg78n6ss23mxxge5slsv2',
    Zil17zvlqn2xamqpumlm2pgul9nezzd3ydmrufxnct = <any>'zil17zvlqn2xamqpumlm2pgul9nezzd3ydmrufxnct',
    Zil10w6ukup76ljmvgn4c25e5kpkjehe6a7vqa5r3y = <any>'zil10w6ukup76ljmvgn4c25e5kpkjehe6a7vqa5r3y',
    Zil1lq3ghn3yaqk0w7fqtszv53hejunpyfyh3rx9gc = <any>'zil1lq3ghn3yaqk0w7fqtszv53hejunpyfyh3rx9gc',
    Zil1w5hwupgc9rxyuyd742g2c9annwahugrx80fw9h = <any>'zil1w5hwupgc9rxyuyd742g2c9annwahugrx80fw9h',
    Zil168qdlq4xsua6ac9hugzntqyasf8gs7aund882v = <any>'zil168qdlq4xsua6ac9hugzntqyasf8gs7aund882v',
    Zil12drvflckms6874ffuujcdxj75raavl4yfn4ssc = <any>'zil12drvflckms6874ffuujcdxj75raavl4yfn4ssc'
}
/**
 *
 * @export
 * @interface TokenDTO
 */
export interface TokenDTO {
    /**
     *
     * @type {TOKENSIDS}
     * @memberof TokenDTO
     */
    tokenId: TOKENSIDS;
    /**
     *
     * @type {string}
     * @memberof TokenDTO
     */
    name: string;
}
/**
 *
 * @export
 * @interface UnlincesedError
 */
export interface UnlincesedError {
    /**
     *
     * @type {string}
     * @memberof UnlincesedError
     */
    name: string;
    /**
     *
     * @type {string}
     * @memberof UnlincesedError
     */
    message: string;
    /**
     *
     * @type {string}
     * @memberof UnlincesedError
     */
    stack?: string;
    /**
     *
     * @type {number}
     * @memberof UnlincesedError
     */
    status?: number;
    /**
     *
     * @type {ModelObject}
     * @memberof UnlincesedError
     */
    data?: any;
}
/**
 *
 * @export
 * @interface UserAlertContracts
 */
export interface UserAlertContracts {
    /**
     *
     * @type {string}
     * @memberof UserAlertContracts
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof UserAlertContracts
     */
    tokenId: string;
    /**
     *
     * @type {number}
     * @memberof UserAlertContracts
     */
    priceTarget: number;
    /**
     *
     * @type {string}
     * @memberof UserAlertContracts
     */
    targetType: TargetTypeEnum;
    /**
     *
     * @type {string}
     * @memberof UserAlertContracts
     */
    trend: TrendEnum;
    /**
     *
     * @type {AlertThrottleEnum}
     * @memberof UserAlertContracts
     */
    throttling: AlertThrottleEnum;
    /**
     *
     * @type {boolean}
     * @memberof UserAlertContracts
     */
    isDisabled?: boolean;
    /**
     *
     * @type {Date}
     * @memberof UserAlertContracts
     */
    lastDetected?: Date;
    /**
     *
     * @type {number}
     * @memberof UserAlertContracts
     */
    lastDetectionPrice?: number;
}

/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates new alert contract
         * @param {CreateNewAlertContractRequestDTO} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewAlertContract(
            body: CreateNewAlertContractRequestDTO,
            options: any = {}
        ): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError(
                    'body',
                    'Required parameter body was null or undefined when calling createNewAlertContract.'
                );
            }
            const localVarPath = `/api/contracts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete (localVarUrlObj as any).search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'CreateNewAlertContractRequestDTO' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(body || {})
                : body || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Returns alert contracts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserContracts(options: any = {}): FetchArgs {
            const localVarPath = `/api/contracts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete (localVarUrlObj as any).search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Login user and return jwt token used for authentication.  If user is not registered in our app (first time calling login) -> unlincesed jwt token is returned
         * @param {LoginUserRequestDTO} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(body: LoginUserRequestDTO, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError(
                    'body',
                    'Required parameter body was null or undefined when calling loginUser.'
                );
            }
            const localVarPath = `/api/users/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete (localVarUrlObj as any).search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'LoginUserRequestDTO' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(body || {})
                : body || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         * Registers new user
         * @param {RegisterUserRequestDTO} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerNewUser(body: RegisterUserRequestDTO, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError(
                    'body',
                    'Required parameter body was null or undefined when calling registerNewUser.'
                );
            }
            const localVarPath = `/api/users/register`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign(
                {},
                localVarUrlObj.query,
                localVarQueryParameter,
                options.query
            );
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete (localVarUrlObj as any).search;
            localVarRequestOptions.headers = Object.assign(
                {},
                localVarHeaderParameter,
                options.headers
            );
            const needsSerialization =
                <any>'RegisterUserRequestDTO' !== 'string' ||
                localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization
                ? JSON.stringify(body || {})
                : body || '';

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Creates new alert contract
         * @param {CreateNewAlertContractRequestDTO} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewAlertContract(
            body: CreateNewAlertContractRequestDTO,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<CreateNewAlertContractResponseDTO> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(
                configuration
            ).createNewAlertContract(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
                    (response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        } else {
                            throw response;
                        }
                    }
                );
            };
        },
        /**
         * Returns alert contracts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserContracts(
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<GetUserContractsResponseDTO> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).getUserContracts(
                options
            );
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
                    (response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        } else {
                            throw response;
                        }
                    }
                );
            };
        },
        /**
         * Login user and return jwt token used for authentication.  If user is not registered in our app (first time calling login) -> unlincesed jwt token is returned
         * @param {LoginUserRequestDTO} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(
            body: LoginUserRequestDTO,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<LoginUserResponseDTO> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).loginUser(
                body,
                options
            );
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
                    (response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response.json();
                        } else {
                            throw response;
                        }
                    }
                );
            };
        },
        /**
         * Registers new user
         * @param {RegisterUserRequestDTO} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerNewUser(
            body: RegisterUserRequestDTO,
            options?: any
        ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).registerNewUser(
                body,
                options
            );
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
                    (response) => {
                        if (response.status >= 200 && response.status < 300) {
                            return response;
                        } else {
                            throw response;
                        }
                    }
                );
            };
        }
    };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
    configuration?: Configuration,
    fetch?: FetchAPI,
    basePath?: string
) {
    return {
        /**
         * Creates new alert contract
         * @param {CreateNewAlertContractRequestDTO} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewAlertContract(body: CreateNewAlertContractRequestDTO, options?: any) {
            return DefaultApiFp(configuration).createNewAlertContract(body, options)(
                fetch,
                basePath
            );
        },
        /**
         * Returns alert contracts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserContracts(options?: any) {
            return DefaultApiFp(configuration).getUserContracts(options)(fetch, basePath);
        },
        /**
         * Login user and return jwt token used for authentication.  If user is not registered in our app (first time calling login) -> unlincesed jwt token is returned
         * @param {LoginUserRequestDTO} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(body: LoginUserRequestDTO, options?: any) {
            return DefaultApiFp(configuration).loginUser(body, options)(fetch, basePath);
        },
        /**
         * Registers new user
         * @param {RegisterUserRequestDTO} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerNewUser(body: RegisterUserRequestDTO, options?: any) {
            return DefaultApiFp(configuration).registerNewUser(body, options)(fetch, basePath);
        }
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Creates new alert contract
     * @param {CreateNewAlertContractRequestDTO} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createNewAlertContract(body: CreateNewAlertContractRequestDTO, options?: any) {
        return DefaultApiFp(this.configuration).createNewAlertContract(body, options)(
            this.fetch,
            this.basePath
        );
    }

    /**
     * Returns alert contracts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserContracts(options?: any) {
        return DefaultApiFp(this.configuration).getUserContracts(options)(
            this.fetch,
            this.basePath
        );
    }

    /**
     * Login user and return jwt token used for authentication.  If user is not registered in our app (first time calling login) -> unlincesed jwt token is returned
     * @param {LoginUserRequestDTO} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public loginUser(body: LoginUserRequestDTO, options?: any) {
        return DefaultApiFp(this.configuration).loginUser(body, options)(this.fetch, this.basePath);
    }

    /**
     * Registers new user
     * @param {RegisterUserRequestDTO} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public registerNewUser(body: RegisterUserRequestDTO, options?: any) {
        return DefaultApiFp(this.configuration).registerNewUser(body, options)(
            this.fetch,
            this.basePath
        );
    }
}
